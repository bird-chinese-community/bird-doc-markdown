## Channel options

Every channel belongs to a protocol and is configured inside its block. The
minimal channel config is empty, then it uses default values. The name of the
channel implies its nettype. Channel definitions can be inherited from protocol
templates. Multiple definitions of the same channel are forbidden, but channels
inherited from templates can be updated by new definitions.

<span id="channel-debug" class="code">debug all\|off\|{ states\|routes\|filters \[, *...*\] }</span>  
Set channel debugging options. Like in [protocol
debugging](#proto-debug), channels are capable of writing trace
    messages about its work to the log (with category `trace`). You can
    either request printing of `all` trace messages or only of the
    selected types: `states` for channel state changes (channel going up,
    down, feeding, reloading etc.), `routes` for routes propagated
    through the channel, `filters` for details on route filtering,
    remaining debug flags are not used in channel debug. Default: off.

<span id="proto-table" class="code">table *name*</span>  
Specify a table to which the channel is connected. Default: the first
    table of given nettype.

<span id="proto-preference" class="code">preference *expr*</span>  
Sets the preference of routes generated by the protocol and imported
    through this channel. Default: protocol dependent.

<span id="proto-import" class="code">import all \| none \| filter *name* \| filter { *filter commands* } \| where *boolean filter expression*</span>  
Specify a filter to be used for filtering routes coming from the
    protocol to the routing table. `all` is for keeping all routes,
    `none` is for dropping all routes. Default: `all` (except for
    EBGP).

<span id="proto-export" class="code">export \[ in *prefix* \] *filter*</span>  
This is similar to the `import` keyword, except that it works in
    the direction from the routing table to the protocol. If `in` keyword is used,
    only routes inside the given prefix are exported. Other routes are completely
    ignored (e.g. no logging and no statistics).
    Default: `none` (except for EBGP and L3VPN).

<span id="proto-import-keep-filtered" class="code">import keep filtered *switch*</span>  
Usually, if an import filter rejects a route, the route is forgotten.
    When this option is active, these routes are kept in the routing table,
    but they are hidden and not propagated to other protocols. But it is
    possible to show them using `show route filtered`. Note that this
    option does not work for the pipe protocol. Default: off.

<span id="proto-rpki-reload" class="code">rpki reload *switch*</span>  
Import or export filters may depend on route RPKI status (using
    `roa_check()` or `aspa_check()` operators). In contrast to other
    filter operators, this status for the same route may change as the
    content of ROA and ASPA tables changes. When this option is active, BIRD
    activates automatic reload of the appropriate subset of prefixes imported
    or exported by the channels whenever ROA and ASPA
    tables are updated (after a short settle time). When disabled, route
    reloads have to be requested manually. The option is ignored if neither
    `roa_check()` nor `aspa_check()` is used in channel filters. Note
    that for BGP channels, automatic reload requires
    [import table](#bgp-import-table) or
    [export table](#bgp-export-table) (for respective
    direction). Default: on.

<span id="proto-import-limit" class="code">import limit \[*number* \| off \] \[action warn \| block \| restart \| disable\]</span>  
Specify an import route limit (a maximum number of routes imported from
    the protocol) and optionally the action to be taken when the limit is
    hit. Warn action just prints warning log message. Block action discards
    new routes coming from the protocol. Restart and disable actions shut
    the protocol down like appropriate commands. Disable is the default
    action if an action is not explicitly specified. Note that limits are
    reset during protocol reconfigure, reload or restart. Default: `off`.

<span id="proto-receive-limit" class="code">receive limit \[*number* \| off \] \[action warn \| block \| restart \| disable\]</span>  
Specify an receive route limit (a maximum number of routes received from
    the protocol and remembered). It works almost identically to `import
    limit` option, the only difference is that if `import keep
    filtered` option is active, filtered routes are counted towards the
    limit and blocked routes are forgotten, as the main purpose of the
    receive limit is to protect routing tables from overflow. Import limit,
    on the contrary, counts accepted routes only and routes blocked by the
    limit are handled like filtered routes. Default: `off`.

<span id="proto-export-limit" class="code">export limit \[ *number* \| off \] \[action warn \| block \| restart \| disable\]</span>  
Specify an export route limit, works similarly to the `import
    limit` option, but for the routes exported to the protocol. This
    option is experimental, there are some problems in details of its
    behavior -- the number of exported routes can temporarily exceed the
    limit without triggering it during protocol reload, exported routes
    counter ignores route blocking and block action also blocks route
    updates of already accepted routes -- and these details will probably
    change in the future. Default: `off`.

<span id="proto-export-block" class="code">export block *number*</span>  
Set the minimum amount of routes exported at once when feeding or
    if \`merge paths\` or \`secondary\` is selected. This affects overall latency.
    Basically, when your export filters are very expensive, processing
    the whole block of routes may take too much time. In such cases, you may need to
        shrink this value to improve responsiveness. Default: `16384`.

This is a trivial example of RIP configured for IPv6 on all interfaces:


    protocol rip ng {
        ipv6;
        interface "*";
    }

This is a non-trivial example.


    protocol rip ng {
        ipv6 {
            table mytable6;
            import filter { ... };
            export filter { ... };
            import limit 50;
        };
        interface "*";
    }

And this is even more complicated example using templates.


    template bgp {
        local 198.51.100.14 as 65000;

        ipv4 {
            table mytable4;
            import filter { ... };
            export none;
        };
        ipv6 {
            table mytable6;
            import filter { ... };
            export none;
        };
    }

    protocol bgp from  {
        neighbor 198.51.100.130 as 64496;

        # IPv4 channel is inherited as-is, while IPv6
        # channel is adjusted by export filter option
        ipv6 {
            export filter { ... };
        };
    }
